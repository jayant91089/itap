% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ itap \mbox{}}}\\
\vfill

\hypersetup{pdftitle= itap }
\markright{\scriptsize \mbox{}\hfill  itap  \hfill\mbox{}}
{\Huge \textbf{ Information Theoretic Achievability Prover \mbox{}}}\\
\vfill

{\Huge  1.0 \mbox{}}\\[1cm]
{ 25/08/2015 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Jayant Apte\\
    \mbox{}}}\\
{\Large \textbf{ John Walsh\\
    \mbox{}}}\\
\hypersetup{pdfauthor= Jayant Apte\\
    ;  John Walsh\\
    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Jayant Apte\\
    }  Email: \href{mailto://jayant91089@gmail.com} {\texttt{jayant91089@gmail.com}}\\
  Homepage: \href{https://sites.google.com/site/jayantapteshomepage/} {\texttt{https://sites.google.com/site/jayantapteshomepage/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Electrical and Computer Engineering\\
 Drexel University\\
 Philadelphia, PA 19104\\
 \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ John Walsh\\
    }  Email: \href{mailto://jwalsh@coe.drexel.edu} {\texttt{jwalsh@coe.drexel.edu}}\\
  Homepage: \href{http://www.ece.drexel.edu/walsh/web/} {\texttt{http://www.ece.drexel.edu/walsh/web/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Electrical and Computer Engineering\\
 Drexel University\\
 Philadelphia, PA 19104\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

 \index{\textsf{itap}}     
\chapter{\textcolor{Chapter }{Introduction}}\label{Chapter_Introduction}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  ITAP stands for Information Theoretic Achievability Prover. So basically, it
is intended for coming up with achievability proofs using a computer. As of
now, it supports the following: 
\begin{itemize}
\item  Achievability proofs of multi-source network coding using vector-linear codes:
answer questions like 'Is this rate vector achievable using a vector linear
code over the given finite field?'. If the answer is `yes` it also returns the
vector linear code it found as a certificate of achievability. Otherwise, it
just says 'no'. 
\item  Achievability proofs with multi-linear secret sharing schemes: answer
questions 'Is there a multi-linear secret sharing scheme over $GF(q)$ for this access structure?' 
\item  Representability test for integer polymatroids over a given finite field:
answer questions like `Is the integer polymatroid associated with this rank
vector linear over $GF(q)$? 
\item  Achievable Rate Region Computation: For a network coding instance, what is the
rate region achievable using linear codes with maximum message size $k$ and maximum code dimension $d$? 
\end{itemize}
 Above questions are very similar to each other, in that, we are looking for
linear representations of integer polymatroids satisfying certain properties
(i.e. network coding constraints, access structure or having a specified rank
vecor respectively). In its most general form an achievability prover is a
computer program that able to answer if there exists a joint distribution
satisfying certain constraints on entropy function. It is not known how to
design such a computer program, as it is closely related to the
characterization of the entropy function. ITAP tries answering this
existential question in a much restricted sense, i.e. with respect to the
joint distributions arising from vector linear codes aka integer linear
polymatroids. The main algorithm underlying ITAP is called Leiterspiel or the
algorithm of snakes and ladders. See \cite{betten2006error} for details. For answering the first question in the above list, one can also
use the algebraic formulation of Koetter and Medard \cite{koetteralgebraic03} or its refinements such as the path gain formulation of Subramanian and
Thangaraj \cite{subrapathgain10}. These formulations lead to a system of polynomial equations over a finite
field and allows one to use Groebner basis computation algorithms to answer
question 1. ITAP currently supports such computation using Singular \cite{DGPS} via the GAP interface to Singular\cite{singulargap}. }

   
\chapter{\textcolor{Chapter }{Installation}}\label{Chapter_Installation}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X8360C04082558A12}{}
{
  ITAP requires GAP interface to singular \cite{singulargap} which is another GAP package. Nowadays, it comes bundled with GAP 4.7+. If
your gap installation doesn't have this package you can follow the
instructions in \cite{singulargap} to install it. To get the newest version of ITAP, download the .zip archive
from \href{https://github.com/jayant91089/itap} {\texttt{https://github.com/jayant91089/itap}} and unpack it using 
\[\texttt{unzip itap-x.zip}\]
 Do this preferably inside the $pkg$ subdirectory of your GAP 4 installation. It creates a subdirectory called $itap$. This completes the installation of the package. If you do not know the
whereabouts of the $pkg$ subdirectory, invoke the following in GAP: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  GAPInfo.("RootPaths");
\end{Verbatim}
 Look for pkg directory inside any of the paths returned. One can then start
using ITAP by invoking 
\[gap>\]
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  LoadPackage( "itap");
\end{Verbatim}
 from within GAP. This would automatically load the GAP interface to singular,
so you don't have to load it seperately. }

   
\chapter{\textcolor{Chapter }{Usage}}\label{Chapter_Usage}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X86A9B6F87E619FFF}{}
{
  
\section{\textcolor{Chapter }{Available functions}}\label{Chapter_Usage_Section_Available_functions}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X835D65A88292737E}{}
{
  In this section we shall look at the functions provided by ITAP. 

\subsection{\textcolor{Chapter }{proverep}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7F1EE7A57984E68C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{proverep({\mdseries\slshape rankvec, nvars, F, optargs})\index{proverep@\texttt{proverep}}
\label{proverep}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 This function checks if there is a linear representation of an integer
polymatroid rank vector. It accepts following arguments: 
\begin{itemize}
\item  $rankvec$ - A list of integers specifying a polymatroid rank vector 
\item  $nvars$ - Number of ground set elements 
\item  $F$ - The finite field over which we wish to find a linear representation. It can
be defined by invoking the following in GAP: 
\end{itemize}
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  q:=4;;
  F:= GF(q);; # here q must be a prime power
\end{Verbatim}
 
\begin{itemize}
\item  $optargs$ is a list of optional arguments $[lazy,..]$ where 
\begin{itemize}
\item  $lazy$ disables lazy evaluation of transporter maps if set to $false$, which is enabled by default in GAP. 
\end{itemize}
 
\end{itemize}
 Returns a list $[true,code]$ if there exists such a representation and $code$ is the vector linear code over $GF(q)$ Returns a list $[false]$ otherwise, indicating that no such representation exists }

 

\subsection{\textcolor{Chapter }{proverate}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7DB2926A78EC4E86}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{proverate({\mdseries\slshape ncinstance, rvec, F, optargs})\index{proverate@\texttt{proverate}}
\label{proverate}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 This function checks if there is a vector linear code achieving the rate
vector $rvec$ for the network coding instance $ncinstance$. Uses enumerative generation methods to syetematically search for the code
with desired properties. It accepts following arguments: 
\begin{itemize}
\item  $ncinstance$ is a list $[cons,nsrc,nvars]$ containing 3 elements: 
\begin{itemize}
\item  $cons$ is a list of network coding constraints. 
\item  $nsrc$ is the number of sources. 
\item  $nvars$ is the number of random variables associated with the network. 
\end{itemize}
 
\item  $rvec$ - A list of $nvars$ integers specifying a rate vector 
\item  $ F$ is the finite field over which we wish to find the vector linear code. It can
be defined by invoking the following in GAP: 
\end{itemize}
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  q:=4;;
  F:= GF(q);; # here q must be a prime power
\end{Verbatim}
 
\begin{itemize}
\item  $optargs$ is a list of optional arguments $[lazy,..]$ where $lazy$ disables lazy evaluation of transporter maps if set to $false$, which is enabled by default. 
\end{itemize}
 Returns a list $[true,code]$ if there exists such a representation and $code$ is the vector linear code over $GF(q)$ Returns a list $[false]$ otherwise, indicating that no such code exists }

 

\subsection{\textcolor{Chapter }{proveregion}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X83FFD00983B6DB00}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{proveregion({\mdseries\slshape ncinstance, k, F, optargs})\index{proveregion@\texttt{proveregion}}
\label{proveregion}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 This function computes the all rate vectors achievable via vector linear
CodeString over the specified fiite field for the network coding instance $ncinstance$. Uses enumerative generation methods to syetematically search for codes with
desired properties. It accepts following arguments: 
\begin{itemize}
\item  $ncinstance$ is a list $[cons,nsrc,nvars]$ containing 3 elements: 
\begin{itemize}
\item  $cons$ is a list of network coding constraints. 
\item  $nsrc$ is the number of sources. 
\item  $nvars$ is the number of random variables associated with the network. 
\end{itemize}
 
\item  $k$ - Maximum number of symbols per message 
\item  $ F$ is the finite field over which we wish to find the vector linear codes. It can
be defined by invoking the following in GAP: 
\end{itemize}
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  q:=4;;
  F:= GF(q);; # here q must be a prime power
\end{Verbatim}
 
\begin{itemize}
\item  $optargs$ is a list of optional arguments $[opt_dmax,..]$ where $opt_dmax$ specifies an upper bound on the dimension of linear codes (alternatively, the
rank of underlying polymatroid) to search. By default this is equal to $nsrc*k$, which may sometimes be unnecessary, and a lower value might suffice. 
\end{itemize}
 Returns a list $[rays,codes]$ where $rays$ is a list of all achievable rate vectors and codes is a list of linear codes. }

 

\subsection{\textcolor{Chapter }{proverate{\textunderscore}groebner}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X7D98B6B27DEE3636}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{proverate{\textunderscore}groebner({\mdseries\slshape ncinstance, rvec, F, optargs})\index{proverategroebner@\texttt{proverate{\textunderscore}groebner}}
\label{proverategroebner}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 This function checks if there is a vector linear code achieving the rate
vector $rvec$ for the network coding instance $ncinstance$. Uses GAP interface to $Singular$ to find Groebner basis of the system of polynomial equations given by the path
gain algebraic construction of Subramanian and Thangraj \cite{subrapathgain10} . It accepts following arguments: 
\begin{itemize}
\item  $ncinstance$ is a list $[cons,nsrc,nvars]$ containing 3 elements: 
\begin{itemize}
\item  $cons$ is a list of network coding constraints. 
\item  $nsrc$ is the number of sources. 
\item  $nvars$ is the number of random variables associated with the network. 
\end{itemize}
 
\item  $rvec$ - A list of $nvars$ integers specifying a rate vector 
\item  $ F$ is the finite field over which we wish to find the vector linear code. It can
be defined by invoking the following in GAP: 
\end{itemize}
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  q:=4;;
  F:= GF(q);; # here q must be a prime power
\end{Verbatim}
 
\begin{itemize}
\item  $optargs$ is a list of optional arguments $[lazy,..]$ where $lazy$ disables lazy evaluation of transporter maps if set to $false$, which is enabled by default. 
\end{itemize}
 Returns a list $[true,code]$ if there exists such a representation where $code$ is the vector linear code over $GF(q)$. Returns a list $[false]$ otherwise, indicating that no such code exists }

 $\textbf{NOTE:}$ Certain naming convensions are followed while defining network coding
instances. The source messages are labeled with $[1...nsrc]$ while rest of the messages are labeled $[nsrc...nvars]$. Furthermore, the list $cons$ includes all network constraints except source independence. This constraint
is implied with the labeling i.e. ITAP enforces it by default for the messages
labeled $[1...nsrc]$. See next section for usage examples. 

\subsection{\textcolor{Chapter }{provess}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X7D75794B7EAD6A00}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{provess({\mdseries\slshape Asets, nvars, svec, F, optargs})\index{provess@\texttt{provess}}
\label{provess}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 This function checks if there is a multi-linear secret sharing scheme with
secret and share sizes given by $svec$ and the access structure $Asets$ with one dealer and $nvars-1$ parties. It accepts following arguments: 
\begin{itemize}
\item  $Asets$ - A list of authorized sets each specified as a subset of $[nvars-1]$ 
\item  $nvars$ - Number of participants (including one dealer) 
\item  $svec$ - vector of integer share sizes understood as number of $\mathbb{F}_q$ symbols, with index 1 giving secret size and index $i,i\in \{2,...,nvars\}$ specifying share sizes of different parties 
\item  $F$ - The finite field over which we wish to find a multi-linear scheme. It can be
defined by invoking the following in GAP: 
\end{itemize}
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  q:=4;;
  F:= GF(q);; # here q must be a prime power
\end{Verbatim}
 
\begin{itemize}
\item  $optargs$ is a list of optional arguments $[lazy,..]$ where 
\begin{itemize}
\item  $lazy$ disables lazy evaluation of transporter maps if set to $false$, which is enabled by default in GAP. 
\end{itemize}
 
\end{itemize}
 Returns a list $[true,code]$ if there exists such a scheme where $code$ is the vector linear code over $GF(q)$. Returns a list $[false]$ otherwise, indicating that no such scheme exists. }

 $\textbf{NOTE:}$ No input checking is performed to verify if input $Asets$ follows labeling convensions. The map returned with a linear scheme is a map $f:[nvars]\rightarrow [nvars]$ with dealer associated with label 1 and parties associated with labels $\{2,...,nvars\}$. See next section for usage examples. 

\subsection{\textcolor{Chapter }{DisplayCode}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X83804D1E7BC6B451}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DisplayCode({\mdseries\slshape code})\index{DisplayCode@\texttt{DisplayCode}}
\label{DisplayCode}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
nothing 



 Displays a network code (or an integer polymatroid). It accepts 1 argument: 
\begin{itemize}
\item  $code$ - A list $[s,map]$ containing 2 elements: 
\begin{itemize}
\item  $s$ - A list of subspaces where is subspace is itself a list of basis vectors 
\item  $map$ - A GAP record mapping subspaces in $s$ to network messages or to polymatroid ground set elements 
\end{itemize}
 
\end{itemize}
 Returns nothing }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s:=[ [ [ 0*Z(2), 0*Z(2), Z(2)^0 ] ], [ [ 0*Z(2), Z(2)^0, 0*Z(2) ] ],\|
  !gapprompt@>| !gapinput@[ [ 0*Z(2), Z(2)^0, Z(2)^0 ] ], [ [ Z(2)^0, 0*Z(2), 0*Z(2) ] ],\|
  !gapprompt@>| !gapinput@[ [ Z(2)^0, 0*Z(2), Z(2)^0 ] ], [ [ Z(2)^0, Z(2)^0, 0*Z(2) ] ],\|
  !gapprompt@>| !gapinput@[ [ Z(2)^0, Z(2)^0, Z(2)^0 ] ] ];;|
  !gapprompt@gap>| !gapinput@map:=rec( 1 := 1, 2 := 2, 3 := 4, 4 := 3, 5 := 6, 6 := 5, 7 := 7 );;|
  !gapprompt@gap>| !gapinput@DisplayCode([s,map]);;|
  1->1
   . . 1
  =============================
  2->2
   . 1 .
  =============================
  3->4
   . 1 1
  =============================
  4->3
   1 . .
  =============================
  5->6
   1 . 1
  =============================
  6->5
  1 1 .
  =============================
  7->7
   1 1 1
  =============================
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{A catalog of examples}}\label{Chapter_Usage_Section_A_catalog_of_examples}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X838C78867A52DDA3}{}
{
  $itap$ comes equipped with a catalog of examples, which contains well-known network
coding instances and integer polymatroids. This catalog is intended to be of
help to the user for getting started with using ITAP. Most of the network
coding instances in this catalog can be found in \cite{YeungBook} and \cite{DFZMatroidNetworks}. Some of the integer polymatroids in the catalog are taken from \href{http://code.ucsd.edu/zeger/linrank/} {\texttt{http://code.ucsd.edu/zeger/linrank/}}. These polymatroids correspond to the extreme rays of the cone of linear rank
inequalities in 5 variables, found by Dougherty, Freiling and Zeger. See \cite{DFZ2009Ineqfor5var} for details. 

\subsection{\textcolor{Chapter }{FanoNet}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7C8C3B34834C6C8F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FanoNet({\mdseries\slshape })\index{FanoNet@\texttt{FanoNet}}
\label{FanoNet}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns the Fano instance. It accepts no arguments. Returns a list. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@FanoNet();|
  [ [ [ [ 1, 2 ], [ 1, 2, 4 ] ], [ [ 2, 3 ], [ 2, 3, 5 ] ],
       [ [ 4, 5 ], [ 4, 5, 6 ] ], [ [ 3, 4 ], [ 3, 4, 7 ] ],
       [ [ 1, 6 ], [ 3, 1, 6 ] ], [ [ 6, 7 ], [ 2, 6, 7 ] ],
       [ [ 5, 7 ], [ 1, 5, 7 ] ] ], 3, 7 ]
  !gapprompt@gap>| !gapinput@rlist:=proverate(FanoNet(),[1,1,1,1,1,1,1],GF(2),[]);;|
  !gapprompt@gap>| !gapinput@rlist[1]; # Fano matroid is representable over GF(2)|
  true
  !gapprompt@gap>| !gapinput@DisplayCode(rlist[2]);|
  1->1
   . . 1
  =============================
  2->2
   . 1 .
  =============================
  3->4
   . 1 1
  =============================
  4->3
   1 . .
  =============================
  5->6
   1 . 1
  =============================
  6->5
   1 1 .
  =============================
  7->7
   1 1 1
  =============================
  !gapprompt@gap>| !gapinput@rlist:=proverate(FanoNet(),[1,1,1,1,1,1,1],GF(3),[]);;|
  !gapprompt@gap>| !gapinput@rlist[1]; # Fano matroid is not representable over GF(3)|
  false
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NonFanoNet}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X7FFA7A277C61E076}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonFanoNet({\mdseries\slshape })\index{NonFanoNet@\texttt{NonFanoNet}}
\label{NonFanoNet}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns the NonFano instance. It accepts no arguments. Returns a list. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@NonFanoNet();|
  !gapprompt@gap>| !gapinput@gap> NonFanoNet();|
  [ [ [ [ 1, 2, 3 ], [ 1, 2, 3, 4 ] ], [ [ 1, 2 ], [ 1, 2, 5 ] ],
        [ [ 1, 3 ], [ 1, 3, 6 ] ], [ [ 2, 3 ], [ 2, 3, 7 ] ],
        [ [ 4, 5 ], [ 3, 4, 5 ] ], [ [ 4, 6 ], [ 2, 4, 6 ] ],
        [ [ 4, 7 ], [ 1, 4, 7 ] ] ], 3, 7 ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{VamosNet}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X826AC373821A9EE2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VamosNet({\mdseries\slshape })\index{VamosNet@\texttt{VamosNet}}
\label{VamosNet}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns the Vamos instance. It accepts no arguments. Returns a list. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@VamosNet();|
  [ [ [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 4, 5 ] ],
        [ [ 1, 2, 5 ], [ 1, 2, 5, 6 ] ],
        [ [ 2, 3, 6 ], [ 2, 3, 6, 7 ] ],
        [ [ 3, 4, 7 ], [ 3, 4, 7, 8 ] ],
        [ [ 4, 8 ], [ 2, 4, 8 ] ],
        [ [ 2, 3, 4, 8 ], [ 1, 2, 3, 4, 8 ] ],
        [ [ 1, 4, 5, 8 ], [ 1, 2, 3, 4, 5, 8 ] ],
        [ [ 1, 2, 3, 7 ], [ 1, 2, 3, 4, 7 ] ],
        [ [ 1, 5, 7 ], [ 1, 3, 5, 7 ] ] ], 3, 7 ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{U2kNet}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X8514B6657A3CC6FF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{U2kNet({\mdseries\slshape })\index{U2kNet@\texttt{U2kNet}}
\label{U2kNet}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns the instance associated with uniform matroid $U^2_k$. It accepts one argument $k$ specifying the size of uniform matroid. Returns a list. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@U2kNet(4);|
   [ [ [ 1, 2 ], [ 1, 2, 3 ] ], [ [ 1, 3 ], [ 1, 3, 4 ] ],
       [ [ 1, 4 ], [ 1, 2, 4 ] ], [ [ 2, 3 ], [ 1, 2, 3 ] ],
       [ [ 2, 4 ], [ 1, 2, 4 ] ], [ [ 3, 4 ], [ 1, 3, 4 ] ] ], 2, 4 ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ButterflyNet}}
\logpage{[ 3, 2, 5 ]}\nobreak
\hyperdef{L}{X8329D29E7FAC98B3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ButterflyNet({\mdseries\slshape })\index{ButterflyNet@\texttt{ButterflyNet}}
\label{ButterflyNet}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns the Butterfly instance. It accepts no arguments. Returns a list. }

 

\subsection{\textcolor{Chapter }{Subspace5}}
\logpage{[ 3, 2, 6 ]}\nobreak
\hyperdef{L}{X808E1A5081F14455}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Subspace5({\mdseries\slshape })\index{Subspace5@\texttt{Subspace5}}
\label{Subspace5}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns the extreme rays of cone formed by linear rank inequalities in 5
variables. It accepts no arguments. Returns a list. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@rays5:=Subspace5();;|
  !gapprompt@gap>| !gapinput@Size(rays5);|
  162
  !gapprompt@gap>| !gapinput@rlist:=proverep(rays5[46],5,GF(2),[])|
  !gapprompt@>| !gapinput@rlist[1];|
  true
  !gapprompt@gap>| !gapinput@gap> DisplayCode(rlist[2]);|
  1->4
   . . . 1
  =============================
  2->5
   . . 1 .
  =============================
  3->3
   . 1 . .
  =============================
  4->2
   1 . . .
   . . 1 1
  =============================
  5->1
   1 . . 1
   . 1 1 1
  =============================
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{BenalohLeichter}}
\logpage{[ 3, 2, 7 ]}\nobreak
\hyperdef{L}{X7AD0AECF7D1E0864}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BenalohLeichter({\mdseries\slshape })\index{BenalohLeichter@\texttt{BenalohLeichter}}
\label{BenalohLeichter}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list of lists specifing authorized subsets of $\{1,2,3,4\}$ 



 Returns the access structure associated with secret sharing scheme of Benaloh
and Leichter that was used to show that share sizes can be larger than secret
size. See \cite{Benaloh90} for details. It accepts no arguments. Returns a list. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@B:=BenalohLeichter();|
  [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ] ]
  !gapprompt@gap>| !gapinput@rlist:=provess(B,5,[2,2,3,3,2],GF(2),[]);;|
  !gapprompt@gap>| !gapinput@rlist[1];|
  true
  !gapprompt@gap>| !gapinput@DisplayCode(rlist[2]);|
  1->1
   . . . . 1 .
  . . . . . 1
  =============================
  2->2
  . . 1 . . .
  . . . 1 . .
  =============================
  3->3
  . 1 . . . .
  . . 1 . . 1
  . . . 1 1 .
  =============================
  4->5
  1 . . . . .
  . 1 . . . .
  =============================
  5->4
  1 . . . . 1
  . 1 . . 1 .
  . . 1 . . .
  =============================
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Threshold}}
\logpage{[ 3, 2, 8 ]}\nobreak
\hyperdef{L}{X7C7738767CA2118A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Threshold({\mdseries\slshape })\index{Threshold@\texttt{Threshold}}
\label{Threshold}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list of lists specifing authorized subsets of $[n]$ 



 Returns the access structure associated with Shamir's $(k,n)$ threshold scheme. See \cite{Shamirhowto79} for details. It accepts following arguments: 
\begin{itemize}
\item  $n$ - number of shares 
\item  $k$ - threshold 
\end{itemize}
 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:=Threshold(4,2);|
  [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
  !gapprompt@gap>| !gapinput@rlist:=provess(T,5,[1,1,1,1,1],GF(2),[]);|
  [ false ]
  !gapprompt@gap>| !gapinput@rlist:=provess(T,5,[1,1,1,1,1],GF(3),[]);|
  [ false ]
  !gapprompt@gap>| !gapinput@rlist:=provess(T,5,[1,1,1,1,1],GF(5),[]);;|
  !gapprompt@gap>| !gapinput@rlist[1];|
  true
  !gapprompt@gap>| !gapinput@gap> DisplayCode(rlist[2]);|
  1->1
   . 1
  =============================
  2->2
   1 .
  =============================
  3->3
   1 1
  =============================
  4->4
   1 2
  =============================
  5->5
  1 4
  =============================
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{HyperedgeNet1}}
\logpage{[ 3, 2, 9 ]}\nobreak
\hyperdef{L}{X85E4AC94816C2D59}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HyperedgeNet1({\mdseries\slshape })\index{HyperedgeNet1@\texttt{HyperedgeNet1}}
\label{HyperedgeNet1}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns a general hyperedge network obtained via enumeration of network coding
instances. See \cite{lihyper15} for details. It accepts no arguments. }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|N:=HyperedgeNet1();B
  [ [ [ [ 1, 2, 3 ], [ 1, 2, 3, 4 ] ], [ [ 1, 3, 4 ], [ 1, 3, 4, 5 ] ],
        [ [ 3, 4, 5 ], [ 3, 4, 5, 6 ] ], [ [ 4, 5 ], [ 1, 3, 4, 5 ] ],
        [ [ 4, 6 ], [ 2, 3, 4, 6 ] ], [ [ 5, 6 ], [ 2, 3, 5, 6 ] ] ], 3, 6 ]
  !gapprompt|gap>B !gapinput|rlist:=proveregion(N,2,GF(2),[4]);; # k=2,opt_dmax=4=max. code dimensionB
  !gapprompt|gap>B !gapinput|Size(rlist[1]); # number of distinct achievable rate vectors foundB
  122
  !gapprompt|gap>B !gapinput|rlist[1][78]; # an achievable rate vectorB
  [ 2, 0, 1, 2, 1, 1 ]
  !gapprompt|gap>B !gapinput|lrs_path:="/home/aspitrg3-users/jayant/lrslib-061/";; # path to lrslibB
  !gapprompt|gap>B !gapinput|rrcompute(rlist[1],N[2],N[3],lrs_path); # compute achievable rate regionB
  
  *redund:lrslib v.6.1 2015.11.20(lrsgmp.h gmp v.5.0)
  *Copyright (C) 1995,2015, David Avis   avis@cs.mcgill.ca
  *Input taken from file /tmp/tmxYdXYT/file1.ext
  *Output sent to file /tmp/tmxYdXYT/file1red.ext
  
  *0.056u 0.004s 648Kb 0 flts 0 swaps 0 blks-in 8 blks-out
  
  
  *lrs:lrslib v.6.1 2015.11.20(lrsgmp.h gmp v.5.0)
  *Copyright (C) 1995,2015, David Avis   avis@cs.mcgill.ca
  *Input taken from file /tmp/tmxYdXYT/file1red.ext
  H-representation
  begin
  ***** 7 rational
   0  0  0  0  1  0  0
   0  1  0  0  0 -1  0
   0  0  0  0  0  1  0
   0  0  0  0  0  0  1
   0  0  0  1  0  0  0
   0  1  1  0 -1 -1 -1
   0  0  1  1  0 -1 -1
   0  0  1  0  0  0  0
   0  1  1  2 -1 -2 -2
   0  1  0  1  0 -1 -1
  end
  *Totals: facets=10 bases=22
  *Dictionary Cache: max size= 6 misses= 0/21   Tree Depth= 5
  *lrs:lrslib v.6.1 2015.11.20(32bit,lrsgmp.h)
  *0.000u 0.000s 648Kb 0 flts 0 swaps 0 blks-in 0 blks-out
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{HyperedgeNet2}}
\logpage{[ 3, 2, 10 ]}\nobreak
\hyperdef{L}{X7C74398F7AB08B95}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HyperedgeNet2({\mdseries\slshape })\index{HyperedgeNet2@\texttt{HyperedgeNet2}}
\label{HyperedgeNet2}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 Returns a general hyperedge network obtained via enumeration of network coding
instances. See \cite{lihyper15} for details. It accepts no arguments. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@N:=HyperedgeNet2();|
  [ [ [ [ 1, 2, 3, 5 ], [ 1, 2, 3, 4, 5 ] ], [ [ 1, 3 ], [ 1, 3, 5 ] ],
       [ [ 3, 4, 5 ], [ 3, 4, 5, 6 ] ], [ [ 4, 5 ], [ 1, 3, 4, 5 ] ],
       [ [ 4, 6 ], [ 2, 3, 4, 6 ] ], [ [ 5, 6 ], [ 2, 3, 5, 6 ] ] ], 3, 6 ]
\end{Verbatim}
 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{itap.bib}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
